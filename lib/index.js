// Generated by LiveScript 1.2.0
(function(){
  var through, crypto, xtend, util, hat, ts, EE, ddb, Cell, ID, Data, Node, Query, slice$ = [].slice;
  through = require('through2');
  crypto = require('crypto');
  xtend = require('xtend');
  util = require('util');
  hat = require('hat');
  ts = require('monotonic-timestamp');
  EE = require('events').EventEmitter;
  ddb = exports;
  ddb.registry = {};
  (function(){
    this.types = {};
    this.from = function(arg$){
      var id, j;
      id = arg$[0], j = arg$[1];
      return this.types[id].fromJson(j);
    };
    this.register = function(type){
      if (this.types[type.id] != null) {
        throw new Error("A cell type with that id: " + util.inspect(type.id) + " is already registered");
      }
      return this.types[type.id] = type;
    };
    this.toJson = function(cell){
      return [cell.constructor.id, cell.toJson()];
    };
  }.call(ddb.registry));
  ddb.Cell = Cell = (function(superclass){
    var prototype = extend$((import$(Cell, superclass).displayName = 'Cell', Cell), superclass).prototype, constructor = Cell;
    prototype.registered = function(db){};
    prototype.id = function(){
      throw new Error(this.constructor.name + " must implement id");
    };
    prototype.toJson = function(){
      throw new Error(this.constructor.name + " must implement to-json");
    };
    prototype.qid = function(){
      return this.constructor.id + "-" + this.id();
    };
    prototype.filter = function(filter){
      return filter === this || filter === this.qid();
    };
    prototype.pipe = function(dest){
      this.createStream({
        writable: false
      }).pipe(dest.createStream({
        readable: false
      }));
      return dest;
    };
    prototype.createStream = function(opts){
      var stream;
      opts == null && (opts = {});
      stream = through({
        objectMode: true
      }, function(u, enc, cb){
        return cb();
      });
      this.on('_update', function(u){
        return stream.push(u);
      });
      return stream;
    };
    prototype.localUpdate = function(d){
      return this._update([d, this.qid()]);
    };
    prototype._update = function(u){
      return this.applyUpdate(u);
    };
    function Cell(){
      Cell.superclass.apply(this, arguments);
    }
    return Cell;
  }(EE));
  ddb.ID = ID = (function(superclass){
    var prototype = extend$((import$(ID, superclass).displayName = 'ID', ID), superclass).prototype, constructor = ID;
    function ID(_id){
      this._id = _id;
    }
    ID.id = 'ddb:id';
    prototype.id = function(){
      return this._id + '';
    };
    prototype.inspect = function(){
      return "#" + this._id;
    };
    prototype.registered = function(node){
      if (this._id == null) {
        return this._id = crypto.createHash('sha1').update(node.id() + '' + ("-" + ts() + "-" + node.rack(this))).digest('hex');
      }
    };
    prototype.toJson = function(){
      return {
        id: this._id
      };
    };
    ID.fromJson = function(j){
      return new this(j.id);
    };
    return ID;
  }(ddb.Cell));
  ddb.registry.register(ddb.ID);
  ddb.Data = Data = (function(superclass){
    var prototype = extend$((import$(Data, superclass).displayName = 'Data', Data), superclass).prototype, constructor = Data;
    function Data(){
      var i$, len$;
      this.data = slice$.call(arguments);
      if (this.constructor.names != null) {
        for (i$ = 0, len$ = this.constructor.names.length; i$ < len$; ++i$) {
          (fn$.call(this, i$, this.constructor.names[i$]));
        }
      }
      function fn$(i, name){
        this[name] = function(newVal){
          if (newVal != null) {
            this.data[i] = newVal;
            return this;
          } else {
            return this.data[i];
          }
        };
      }
    }
    Data.id = 'ddb:data';
    prototype.inspect = function(){
      return [
        '(', this.data.map(function(it){
          return util.inspect(it);
        }).join(', '), ')'
      ].join('');
    };
    prototype.id = function(){
      return this.data.map(JSON.stringify).join('-');
    };
    prototype.toJson = function(){
      return this.data;
    };
    Data.fromJson = function(j){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(this, j, function(){});
    };
    prototype.filter = function(filter){
      var i$, ref$, len$, i, d;
      if (filter instanceof ddb.Data) {
        for (i$ = 0, len$ = (ref$ = filter.data).length; i$ < len$; ++i$) {
          i = i$;
          d = ref$[i$];
          if (!(d != null && this.data[i] === d)) {
            return false;
          }
        }
        return true;
      }
      return superclass.prototype.filter.call(this, filter);
    };
    return Data;
  }(ddb.Cell));
  ddb.registry.register(ddb.Data);
  ddb.Node = Node = (function(superclass){
    var prototype = extend$((import$(Node, superclass).displayName = 'Node', Node), superclass).prototype, constructor = Node;
    Node.id = 'ddb:node';
    function Node(){
      Node.superclass.call(this);
      this.cells = {};
      this._assocs = {};
      this.hist = {};
      this.rack = hat.rack();
      this.registered(this);
      this.register(this);
    }
    prototype.inspect = function(){
      return "<Node" + superclass.prototype.inspect.call(this) + ">";
    };
    prototype.register = function(cell){
      var this$ = this;
      if (this.cells[cell.qid()] == null) {
        cell.registered(this);
        this.cells[cell.qid()] = cell;
        if (cell !== this) {
          cell.on('_update', function(u){
            return this$.localUpdate(['u', cell.qid(), u]);
          });
        }
        this.assoc(this, cell);
        this.emit('register', cell);
      }
      return this;
    };
    prototype.assoc = function(a, b){
      var this$ = this;
      (function(){
        var assocs;
        assocs = this$._assocs[a.qid()];
        if (assocs == null) {
          assocs = [];
          this$._assocs[a.qid()] = assocs;
        }
        if (!~assocs.indexOf(b.qid())) {
          return assocs.push(b.qid());
        }
      })();
      (function(){
        var assocs;
        assocs = this$._assocs[b.qid()];
        if (assocs == null) {
          assocs = [];
          this$._assocs[b.qid()] = assocs;
        }
        if (!~assocs.indexOf(a.qid())) {
          return assocs.push(a.qid());
        }
      })();
      this.emit('assoc', a, b);
      return this;
    };
    prototype.assocs = function(cell, filter){
      var res, this$ = this;
      cell == null && (cell = this);
      if (this._assocs[cell.qid()]) {
        res = this._assocs[cell.qid()].map(function(it){
          return this$.cells[it];
        });
        if (filter != null) {
          res = res.filter(function(it){
            return it.filter(filter);
          });
        }
        return res;
      } else {
        return [];
      }
    };
    prototype.applyUpdate = function(u){
      var d, cell;
      d = u[0];
      switch (d[0]) {
      case 'r':
        cell = ddb.registry.from(d[1]);
        return this.register(cell);
      }
    };
    prototype.history = function(){
      var hist, id, ref$, u, cell;
      hist = [];
      for (id in ref$ = this.hist) {
        u = ref$[id];
        hist.push(u);
      }
      for (id in ref$ = this.cells) {
        cell = ref$[id];
        hist = hist.concat(cell.history());
      }
      return hist;
    };
    return Node;
  }(ddb.ID));
  ddb.registry.register(ddb.Node);
  ddb.Query = Query = (function(){
    Query.displayName = 'Query';
    var Assoc, Nodes, Filter, AssocFilter, FilterOut, prototype = Query.prototype, constructor = Query;
    function Query(node){
      this.node = node;
      this.base = slice$.call(arguments, 1);
      if (!this.base.length) {
        this.base.push(this.node);
      }
      this.parts = [];
    }
    prototype.assoc = function(filter){
      return this.parts.push(new constructor.Assoc(filter));
    };
    prototype.add = function(){
      var cells;
      cells = slice$.call(arguments);
      return this.parts.push((function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(constructor.Nodes, cells, function(){}));
    };
    prototype.filter = function(filter){
      return this.parts.push(new constructor.Filter(filter));
    };
    prototype.filterAssoc = function(cell, deep){
      return this.parts.push(new constructor.AssocFilter(cell, deep));
    };
    prototype.filterOut = function(){
      var cells;
      cells = slice$.call(arguments);
      return this.parts.push((function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(constructor.FilterOut, cells, function(){}));
    };
    prototype.run = function(){
      var this$ = this;
      return this.parts.reduce(function(acc, part){
        return part.find(this$.node, acc);
      }, this.base);
    };
    Query.Assoc = Assoc = (function(){
      Assoc.displayName = 'Assoc';
      var prototype = Assoc.prototype, constructor = Assoc;
      function Assoc(filter){
        this.filter = filter;
      }
      prototype.find = function(node, prev){
        var this$ = this;
        return prev.reduce(function(acc, cell){
          var assocs, i$, len$;
          acc = acc.slice();
          assocs = node.assocs(cell, this$.filter);
          for (i$ = 0, len$ = assocs.length; i$ < len$; ++i$) {
            cell = assocs[i$];
            if (acc.indexOf(cell) === -1) {
              acc.push(cell);
            }
          }
          return acc;
        }, []);
      };
      return Assoc;
    }());
    Query.Nodes = Nodes = (function(){
      Nodes.displayName = 'Nodes';
      var prototype = Nodes.prototype, constructor = Nodes;
      function Nodes(){
        this.cells = slice$.call(arguments);
      }
      prototype.find = function(node, prev){
        var after, i$, ref$, len$, cell;
        after = prev.slice();
        for (i$ = 0, len$ = (ref$ = this.cells).length; i$ < len$; ++i$) {
          cell = ref$[i$];
          if (after.indexOf(cell) === -1) {
            after.push(cell);
          }
        }
        return after;
      };
      return Nodes;
    }());
    Query.Filter = Filter = (function(){
      Filter.displayName = 'Filter';
      var prototype = Filter.prototype, constructor = Filter;
      function Filter(filter){
        this.filter = filter;
      }
      prototype.find = function(node, prev){
        var this$ = this;
        return prev.filter(function(it){
          return it.filter(this$.filter);
        });
      };
      return Filter;
    }());
    Query.AssocFilter = AssocFilter = (function(){
      AssocFilter.displayName = 'AssocFilter';
      var prototype = AssocFilter.prototype, constructor = AssocFilter;
      function AssocFilter(cell, deep){
        this.cell = cell;
        this.deep = deep != null ? deep : false;
        if (deep) {
          throw new Error('not implemented');
        }
      }
      prototype.find = function(node, prev){
        var this$ = this;
        return prev.filter(function(it){
          return node.assocs(it).indexOf(this$.cell) !== -1;
        });
      };
      return AssocFilter;
    }());
    Query.FilterOut = FilterOut = (function(){
      FilterOut.displayName = 'FilterOut';
      var prototype = FilterOut.prototype, constructor = FilterOut;
      function FilterOut(){
        this.cells = slice$.call(arguments);
      }
      prototype.find = function(node, prev){
        var this$ = this;
        return prev.filter(function(it){
          return this$.cells.indexOf(it) === -1;
        });
      };
      return FilterOut;
    }());
    return Query;
  }());
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
